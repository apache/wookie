<?xml version="1.0" encoding="utf-8"?>
<widget minimumVersion="4.0">

<settings>
	<setting name="defaultTracking" value="rectangle"/>
	<setting name="allowCustomObjectAttributes" value="true"/>
	<setting name="debug" value="off"/>
</settings>

<script>
	var mWgt_doc = XMLDOM.createDocument();
	var mWgt_v = mWgt_doc.createElement("dock-item");
	
	var miniWidget_base = mWgt_doc.createElement( "image" );
	miniWidget_base.setAttribute("src","Resources/mw_base.png");
	
	mWgt_doc.appendChild( mWgt_v );
	mWgt_v.appendChild(miniWidget_base);
	widget.setDockItem( mWgt_doc );
</script>

<!--
	Yahoo! Maps
	Design & Code: Rob Marquardt

	Looking for yourself?  Let us help you.

	1.0   - Initial release.
	1.0.1 - Swapped arrow directions.
	1.1	  - Searchin' for the satellites.


	Copyright (C) 2005 - 2007 Yahoo! Inc.  All Rights Reserved.
-->

	<window title="Yahoo! Maps">
		<name>mainWindow</name>
		<visible>0</visible>
		<shadow>0</shadow>

		<frame name="scrollFrame">
			<hOffset>4</hOffset>

			<frame name="sidebarFrame">
				<hOffset>86</hOffset> <!-- 86 to 330 -->
				<vOffset>52</vOffset>

				<image name="drawerBackground" src="Resources/drawer bkgnd.png">
					<hOffset>9</hOffset>
					<vOffset>6</vOffset>
				</image>
	
				<frame name="sidebarContentMaskFrame">
					<hOffset>11</hOffset>
					<vOffset>24</vOffset>
					<width>240</width>
					<height>272</height>
					<vScrollBar>sidebarScrollbar</vScrollBar>
				</frame>
			
				<image name="drawer" src="Resources/drawer.png"/>

				<scrollbar name="sidebarScrollbar">
					<hOffset>230</hOffset>
					<vOffset>29</vOffset>
					<width>16</width>
					<height>263</height>
					<thumbColor>#000000</thumbColor>
					<autoHide>true</autoHide>
				</scrollbar>

				<text name="searchResultsLabel" data="Search Results">
					<hOffset>131</hOffset>
					<vOffset>20</vOffset>
					<alignment>center</alignment>
					<font>Arial Bold</font>
					<size>11</size>
					<color>#3B3B3B</color>
					<shadow color="#FFFFFF" vOffset="1"/>
				</text>

			</frame>

			<image name="scrollBackground" src="Resources/loading tile.png">
				<hOffset>26</hOffset>
				<vOffset>52</vOffset>
				<width>305</width>
				<height>304</height>
				<fillMode>tile</fillMode>
				<zOrder>5</zOrder>
			</image>
		
			<image name="scroll" src="Resources/scroll.png">
				<vOffset>1</vOffset>
				<zOrder>20</zOrder>
			</image>

			<text name="copyright">
				<hOffset>320</hOffset>
				<vOffset>348</vOffset>
				<alignment>right</alignment>
				<font>Arial Bold</font>
				<size>9</size>
				<color>#424242</color>
				<shadow color="#FFFFFF" vOffset="1"/>
				<zOrder>25</zOrder>
			</text>

			<image name="zoomControlOut" src="Resources/button minus.png">
				<hOffset>14</hOffset>
				<vOffset>13</vOffset>
				<zOrder>25</zOrder>
				<onMouseEnter>buttonOver = "zoomControlOut"</onMouseEnter>
				<onMouseExit>buttonOver = null</onMouseExit>
			</image>

			<image name="zoomControlIn" src="Resources/button plus.png">
				<hOffset>100</hOffset>
				<vOffset>13</vOffset>
				<zOrder>25</zOrder>
				<onMouseEnter>buttonOver = "zoomControlIn"</onMouseEnter>
				<onMouseExit>buttonOver = null</onMouseExit>
			</image>

			<image name="zoomControlThumb" src="Resources/button thumb.png">
				<hOffset>32</hOffset>
				<vOffset>13</vOffset>
				<zOrder>25</zOrder>
			</image>

			<image name="sidebarDisclosureButton" src="Resources/drawer disclosure button.png">
				<hRegistrationPoint>7</hRegistrationPoint>
				<vRegistrationPoint>7</vRegistrationPoint>
				<hOffset>338</hOffset>
				<vOffset>203</vOffset>
				<rotation>0</rotation>
				<onMouseEnter>buttonOver = "sidebarDisclosureButton"</onMouseEnter>
				<onMouseExit>buttonOver = null</onMouseExit>
				<onMouseUp>if ( buttonOver == "sidebarDisclosureButton" ) handleSidebarDisclosure( )</onMouseUp>
				<zOrder>25</zOrder>
			</image>

			<image name="mapMode_map" src="Resources/button map 1.png">
				<hOffset>146</hOffset>
				<vOffset>357</vOffset>
				<zOrder>25</zOrder>
				<onMouseEnter>buttonOver = "mapMode_map"</onMouseEnter>
				<onMouseExit>buttonOver = null</onMouseExit>
				<onMouseUp>if ( buttonOver == "mapMode_map" && mapMode != "map" ) changeMapMode( "map" )</onMouseUp>
			</image>

			<image name="mapMode_hyb" src="Resources/button hyb 0.png">
				<hOffset>203</hOffset>
				<vOffset>357</vOffset>
				<zOrder>25</zOrder>
				<onMouseEnter>buttonOver = "mapMode_hyb"</onMouseEnter>
				<onMouseExit>buttonOver = null</onMouseExit>
				<onMouseUp>if ( buttonOver == "mapMode_hyb" && mapMode != "hyb" ) changeMapMode( "hyb" )</onMouseUp>
			</image>

			<image name="mapMode_sat" src="Resources/button sat 0.png">
				<hOffset>260</hOffset>
				<vOffset>357</vOffset>
				<zOrder>25</zOrder>
				<onMouseEnter>buttonOver = "mapMode_sat"</onMouseEnter>
				<onMouseExit>buttonOver = null</onMouseExit>
				<onMouseUp>if ( buttonOver == "mapMode_sat" && mapMode != "sat" ) changeMapMode( "sat" )</onMouseUp>
			</image>

			<image name="header" src="Resources/header.png">
				<hOffset>120</hOffset>
				<zOrder>30</zOrder>
			</image>

			<image name="disclosureButton" src="Resources/disclosure button.png">
				<hOffset>332</hOffset>
				<vOffset>10</vOffset>
				<onMouseEnter>buttonOver = "disclosureButton"</onMouseEnter>
				<onMouseExit>buttonOver = null</onMouseExit>
				<onMouseUp>if ( buttonOver == "disclosureButton" ) handleScrollDisclosure( )</onMouseUp>
				<zOrder>35</zOrder>
			</image>
		
			<image name="disclosureButtonArrow" src="Resources/disclosure arrow.png">
				<hOffset>340</hOffset>
				<vOffset>18</vOffset>
				<hRegistrationPoint>8</hRegistrationPoint>
				<vRegistrationPoint>7</vRegistrationPoint>
				<rotation>0</rotation>
				<zOrder>36</zOrder>
			</image>

			<image name="searchIcon" src="Resources/search icon.png">
				<hOffset>138</hOffset>
				<vOffset>12</vOffset>
				<onMouseDown>handleRecentSearchMenu( )</onMouseDown>
				<zOrder>35</zOrder>
			</image>

			<textarea name="searchField" data="Search">
				<hOffset>156</hOffset>
				<vOffset>12</vOffset>
				<width>154</width>
				<alignment>left</alignment>
				<font>Arial</font>
				<size>12</size>
				<lines>1</lines>
				<scrollbar>false</scrollbar>
				<spellcheck>false</spellcheck>
				<color>#BCBCBC</color>
				<onKeyPress>handleKeyPress( )</onKeyPress>
				<onGainFocus>handleSearchFieldGainFocus( )</onGainFocus>
				<onLoseFocus>handleSearchFieldLoseFocus( )</onLoseFocus>
				<zOrder>40</zOrder>
			</textarea>

			<image name="searchFieldFocusRing" src="Resources/focus ring.png">
				<hOffset>128</hOffset>
				<vOffset>3</vOffset>
				<opacity>0</opacity>
				<zOrder>41</zOrder>
			</image>

		</frame>

		<image name="footer" src="Resources/lower blob.png"/>

	</window>

	<action trigger="onLoad">
		<![CDATA[

			const viewportH = 52;
			const viewportV = 98;
			const viewportWidth = 300;
			const viewportHeight = 300;

			const tileSize = 256;
			const tileOverlap = 2;
			const tileCount = 3;

			const minZoomLevel = 17;
			const maxZoomLevel = 1;
			const zoomThumbStep = 59 / ( minZoomLevel - maxZoomLevel );

			const storedSearchCount = 10;

			var zoomLevel = 8;
			var clickOffsetX = 0;
			var clickOffsetY = 0;
			var clickedTileX = 0;
			var clickedTileY = 0;
			var originH = 31;
			var originV = 77;
			
			var masterLat = 0;
			var masterLon = 0;

			var oScroll = null;
			var oSidebar = null;
			var cScroll = null;
			var cSidebar = null;

			var mapMode = "map";
			var scrollIsClosed = true;
			var sidebarIsClosed = true;
			var haveRenderedMap = false;
			var activeViewport = 0;
			var selectedSidebar = 0;
			sidebarFrame.visible = false;
			
			var sidebarList = new Array ( );
			var pinList = new Array ( );
			pinList[0] = new Array ( );
			pinList[1] = new Array ( );

			var mapViewport = new Array ( );

			var tileURL = new Array( );
			tileURL[ "map" ] = 'http://us.i1.yimg.com/png.maps.yimg.com/png?v=3.0.1&';
			tileURL[ "hyb" ] = 'http://us.maps3.yimg.com/aerial.maps.yimg.com/png?v=1.0&t=h&';
			tileURL[ "sat" ] = 'http://us.maps3.yimg.com/aerial.maps.yimg.com/tile?v=1.3&t=a&';

			var pinTextShadow = new Shadow ( );
			pinTextShadow.vOffset = -1;
			pinTextShadow.hOffset = 0;
			pinTextShadow.color = "#A10000";
			
			for( var n = 0; n <= 1; n++ )
			{
				mapViewport[n] = new Frame( );
				mapViewport[n].hOffset = 28;
				mapViewport[n].vOffset = 53;
				mapViewport[n].width = 300;
				mapViewport[n].height = 300;
				mapViewport[n].zOrder = 11 - n;
				scrollFrame.addSubview( mapViewport[n] );
			}

			var mapTiles = new Array( );

			for( var n = 0; n <= 1; n++ )
			{
				mapTiles[n] = new Array( );
				for( var x = 0; x < tileCount; x++ )
				{
					mapTiles[n][x] = new Array( );
					for( var y = 0; y < tileCount; y++ )
					{
						mapTiles[n][x][y] = new Image( );
						mapTiles[n][x][y].b = new Image( );

						mapTiles[n][x][y].clipRect = "1, 1, " + tileSize + ", " + tileSize; 
						mapTiles[n][x][y].b.clipRect = "1, 1, " + tileSize + ", " + tileSize; 
						
						mapViewport[n].addSubview( mapTiles[n][x][y].b );
						mapViewport[n].addSubview( mapTiles[n][x][y] );
					}
				}
			}
			zoomControlIn.storedOnMouseUp = "zoomIn( )";
			zoomControlOut.storedOnMouseUp = "zoomOut( )";
			
			zoomControlThumb.storedOnMouseDrag = "dragThumb( )";
			zoomControlThumb.storedOnMouseDown = "thumbClickOffsetX = system.event.x";
			zoomControlThumb.storedOnMouseUp = "zoomTo( )";

			zoomControlThumb.hOffset = 91 - zoomThumbStep * ( zoomLevel - 1 );

			scrollFrame.height = 36

			var today = new Date( );
			copyright.data="Data \u00A9" + today.getFullYear( ) + " Navteq and TeleAtlas";

			mainWindow.visible = true;

			//---------------------------------------------------------------------

			function generateTile( posH, posV, tileX, tileY, offsetX, offsetY )
			{
				if( mapMode == "hyb" )
				{
					mapTiles[activeViewport][posH][posV].b.width = tileSize + tileOverlap;
					mapTiles[activeViewport][posH][posV].b.height = tileSize + tileOverlap;
					
					mapTiles[activeViewport][posH][posV].b.hOffset = offsetX;
					mapTiles[activeViewport][posH][posV].b.vOffset = offsetY;
					mapTiles[activeViewport][posH][posV].b.zOrder = 49;
					mapTiles[activeViewport][posH][posV].b.remoteAsync = true;
					mapTiles[activeViewport][posH][posV].b.loadingSrc = "Resources/loading tile.png";
					mapTiles[activeViewport][posH][posV].b.missingSrc = null;
					mapTiles[activeViewport][posH][posV].b.src = getUrl( tileX, tileY, zoomLevel, true );
					mapTiles[activeViewport][posH][posV].b.tileX = tileX;
					mapTiles[activeViewport][posH][posV].b.tileY = tileY;


					mapTiles[activeViewport][posH][posV].width = tileSize + tileOverlap;
					mapTiles[activeViewport][posH][posV].height = tileSize + tileOverlap;
					
					mapTiles[activeViewport][posH][posV].hOffset = offsetX;
					mapTiles[activeViewport][posH][posV].vOffset = offsetY;
					mapTiles[activeViewport][posH][posV].zOrder = 50;
					mapTiles[activeViewport][posH][posV].remoteAsync = true;
					mapTiles[activeViewport][posH][posV].loadingSrc = "Resources/loading tile.png";
					mapTiles[activeViewport][posH][posV].missingSrc = "Resources/loading tile.png";
					mapTiles[activeViewport][posH][posV].src = getUrl( tileX, tileY, zoomLevel );
					mapTiles[activeViewport][posH][posV].onMouseDrag = "dragTile( )";
					mapTiles[activeViewport][posH][posV].onMouseDown = "clickOffsetX = system.event.hOffset; clickOffsetY = system.event.vOffset";
					mapTiles[activeViewport][posH][posV].tileX = tileX;
					mapTiles[activeViewport][posH][posV].tileY = tileY;
				}
				else
				{
					mapTiles[activeViewport][posH][posV].b.src = null;

					mapTiles[activeViewport][posH][posV].width = tileSize + tileOverlap;
					mapTiles[activeViewport][posH][posV].height = tileSize + tileOverlap;
					
					mapTiles[activeViewport][posH][posV].hOffset = offsetX;
					mapTiles[activeViewport][posH][posV].vOffset = offsetY;
					mapTiles[activeViewport][posH][posV].zOrder = 50;
					mapTiles[activeViewport][posH][posV].remoteAsync = true;
					mapTiles[activeViewport][posH][posV].loadingSrc = "Resources/loading tile.png";
					mapTiles[activeViewport][posH][posV].missingSrc = "Resources/loading tile.png";
					mapTiles[activeViewport][posH][posV].src = getUrl( tileX, tileY, zoomLevel );
					mapTiles[activeViewport][posH][posV].onMouseDrag = "dragTile( )";
					mapTiles[activeViewport][posH][posV].onMouseDown = "clickOffsetX = system.event.hOffset; clickOffsetY = system.event.vOffset";
					mapTiles[activeViewport][posH][posV].tileX = tileX;
					mapTiles[activeViewport][posH][posV].tileY = tileY;
				}
			}

			//---------------------------------------------------------------------

			function getUrl( x, y, z, forceSat )
			{
				if( forceSat )
					return tileURL[ "sat" ] + "x=" + x + "&y=" + y + "&z=" + z;
				else
					return tileURL[ mapMode ] + "x=" + x + "&y=" + y + "&z=" + z;
			}

			//---------------------------------------------------------------------

			function toggle( n )
			{
				return Math.abs( 1 - n );
			}
			
			//---------------------------------------------------------------------

			function changeMapMode( mode )
			{
				eval( "mapMode_" + mapMode + ".src = 'Resources/button " + mapMode + " 0.png'" );
				eval( "mapMode_" + mode + ".src = 'Resources/button " + mode + " 1.png'" );
				
				mapMode = mode;

				if ( haveRenderedMap )
				{
					var center = findCenterLatLon( );

					activeViewport = toggle( activeViewport );
	
					getMap( center.m_lat, center.m_lon );
					positionPins( center.m_lat, center.m_lon );

					fadeMapFrame( toggle( activeViewport ) );
				}
			}
			
			//---------------------------------------------------------------------

			function normalize( uppercaseString )
			{
				var stringSplit = uppercaseString.split( " " );
				var returnedString = "";

				for ( var i = 0; i < stringSplit.length; i++ )
					returnedString += stringSplit[ i ].charAt( 0 ) + stringSplit[ i ].substring( 1 ).toLowerCase( ) + " ";

				return returnedString.substring( 0, returnedString.length - 1 );
			}

			//---------------------------------------------------------------------

			function dragTile( )
			{
				var hOff = system.event.hOffset;
				var vOff = system.event.vOffset;

				for ( var y = 0; y < tileCount; y++ )
				{
					for ( var x = 0; x < tileCount; x++ )
					{
						mapTiles[activeViewport][x][y].b.hOffset = mapTiles[activeViewport][x][y].hOffset += ( hOff - clickOffsetX );
						mapTiles[activeViewport][x][y].b.vOffset = mapTiles[activeViewport][x][y].vOffset += ( vOff - clickOffsetY );
					}
				}

				for ( var i = 0; i < pinList[ activeViewport ].length; i++ )
				{
					pinList[ activeViewport ][ i ].pinText.hOffset += ( hOff - clickOffsetX );
					pinList[ activeViewport ][ i ].pinText.vOffset += ( vOff - clickOffsetY );
					pinList[ activeViewport ][ i ].pin.hOffset += ( hOff - clickOffsetX );
					pinList[ activeViewport ][ i ].pin.vOffset += ( vOff - clickOffsetY );
				}

				clickOffsetX = hOff;
				clickOffsetY = vOff;
				
				checkTileLimits( );				
			}

			//---------------------------------------------------------------------

			function dragThumb( )
			{
				var hOff = system.event.hOffset - scrollFrame.hOffset - thumbClickOffsetX;

				if ( hOff <= 32 )
					hOff = 32;
				else if ( hOff >= 91 )
					hOff = 91;
				
				hOff = 32 + ( Math.round( ( hOff - 32 ) / zoomThumbStep ) * zoomThumbStep );
				
				zoomControlThumb.hOffset = hOff;
			}

			//---------------------------------------------------------------------

			function checkTileLimits( recurse )
			{
				var updated = false;
				
				var threshold = ( tileSize * tileCount ) / 2;

				if ( mapTiles[activeViewport][0][0].hOffset < 0 - threshold ) 
					shuffleRight( );
					
				if ( mapTiles[activeViewport][0][0].hOffset > tileSize - threshold ) 
					shuffleLeft( );

				if ( mapTiles[activeViewport][0][0].vOffset < 0 - threshold ) 
					shuffleDown( );
					
				if ( mapTiles[activeViewport][0][0].vOffset > tileSize - threshold  ) 
					shuffleUp( );
				
//				if( recurse && updated ) updated = false; checkTileLimits( true );
			}

			//---------------------------------------------------------------------

			function shuffleRight( )
			{
				if( mapMode == "hyb" )
				{
					for( var y = 0; y < tileCount; y++ )
					{
						var temp = mapTiles[activeViewport][0][y];
						var tempB = mapTiles[activeViewport][0][y].b;
		
						for( var x = 0; x < tileCount - 1; x++ )
						{
							mapTiles[activeViewport][x][y] = mapTiles[activeViewport][x + 1][y];
							mapTiles[activeViewport][x][y].b = mapTiles[activeViewport][x + 1][y].b;
						}
		
						mapTiles[activeViewport][tileCount - 1][y] = temp;
						mapTiles[activeViewport][tileCount - 1][y].b = tempB;
						
						mapTiles[activeViewport][tileCount - 1][y].b.hOffset = mapTiles[activeViewport][tileCount - 1][y].hOffset += tileSize * tileCount;
						mapTiles[activeViewport][tileCount - 1][y].b.tileX = mapTiles[activeViewport][tileCount - 1][y].tileX += tileCount;
						
						mapTiles[activeViewport][tileCount - 1][y].src = getUrl( mapTiles[activeViewport][tileCount - 1][y].tileX, mapTiles[activeViewport][tileCount - 1][y].tileY, zoomLevel );
						mapTiles[activeViewport][tileCount - 1][y].b.src = getUrl( mapTiles[activeViewport][tileCount - 1][y].tileX, mapTiles[activeViewport][tileCount - 1][y].tileY, zoomLevel, true );
					}
				}
				else
				{
					for( var y = 0; y < tileCount; y++ )
					{
						var temp = mapTiles[activeViewport][0][y];
		
						for( var x = 0; x < tileCount - 1; x++ )
							mapTiles[activeViewport][x][y] = mapTiles[activeViewport][x + 1][y];
		
						mapTiles[activeViewport][tileCount - 1][y] = temp;
						mapTiles[activeViewport][tileCount - 1][y].hOffset += tileSize * tileCount;
						mapTiles[activeViewport][tileCount - 1][y].tileX += tileCount;
						mapTiles[activeViewport][tileCount - 1][y].src = getUrl( mapTiles[activeViewport][tileCount - 1][y].tileX, mapTiles[activeViewport][tileCount - 1][y].tileY, zoomLevel );
					}
				}
			}

			//---------------------------------------------------------------------

			function shuffleLeft( )
			{
				if( mapMode == "hyb" )
				{
					for( var y = 0; y < tileCount; y++ )
					{
						var temp = mapTiles[activeViewport][tileCount - 1][y];
						var tempB = mapTiles[activeViewport][tileCount - 1][y].b;
	
						for( var x = tileCount - 1; x > 0; x-- )
						{
							mapTiles[activeViewport][x][y] = mapTiles[activeViewport][x - 1][y];
							mapTiles[activeViewport][x][y].b = mapTiles[activeViewport][x - 1][y].b;
						}
		
						mapTiles[activeViewport][0][y] = temp;
						mapTiles[activeViewport][0][y].b = tempB;

						mapTiles[activeViewport][0][y].b.hOffset = mapTiles[activeViewport][0][y].hOffset -= tileSize * tileCount;
						mapTiles[activeViewport][0][y].b.tileX = mapTiles[activeViewport][0][y].tileX -= tileCount;
						
						mapTiles[activeViewport][0][y].src = getUrl( mapTiles[activeViewport][0][y].tileX, mapTiles[activeViewport][0][y].tileY, zoomLevel );
						mapTiles[activeViewport][0][y].b.src = getUrl( mapTiles[activeViewport][0][y].tileX, mapTiles[activeViewport][0][y].tileY, zoomLevel, true );
					}
				}
				else
				{
					for( var y = 0; y < tileCount; y++ )
					{
						var temp = mapTiles[activeViewport][tileCount - 1][y];
	
						for( var x = tileCount - 1; x > 0; x-- )
							mapTiles[activeViewport][x][y] = mapTiles[activeViewport][x - 1][y];
		
						mapTiles[activeViewport][0][y] = temp;
						mapTiles[activeViewport][0][y].hOffset -= tileSize * tileCount;
						mapTiles[activeViewport][0][y].tileX -= tileCount;
						mapTiles[activeViewport][0][y].src = getUrl( mapTiles[activeViewport][0][y].tileX, mapTiles[activeViewport][0][y].tileY, zoomLevel );
					}
				}
			}

			//---------------------------------------------------------------------

			function shuffleDown( )
			{
				if( mapMode == "hyb" )
				{
					for( var x = 0; x < tileCount; x++ )
					{
						var temp = mapTiles[activeViewport][x][0];
						var tempB = mapTiles[activeViewport][x][0].b;
	
						for( var y = 0; y < tileCount - 1; y++ )
						{
							mapTiles[activeViewport][x][y] = mapTiles[activeViewport][x][y + 1];
							mapTiles[activeViewport][x][y].b = mapTiles[activeViewport][x][y + 1].b;
						}
		
						mapTiles[activeViewport][x][tileCount - 1] = temp;
						mapTiles[activeViewport][x][tileCount - 1].b = tempB;

						mapTiles[activeViewport][x][tileCount - 1].b.vOffset = mapTiles[activeViewport][x][tileCount - 1].vOffset += tileSize * tileCount;
						mapTiles[activeViewport][x][tileCount - 1].b.tileY = mapTiles[activeViewport][x][tileCount - 1].tileY -= tileCount;
						
						mapTiles[activeViewport][x][tileCount - 1].src = getUrl( mapTiles[activeViewport][x][tileCount - 1].tileX, mapTiles[activeViewport][x][tileCount - 1].tileY, zoomLevel );
						mapTiles[activeViewport][x][tileCount - 1].b.src = getUrl( mapTiles[activeViewport][x][tileCount - 1].tileX, mapTiles[activeViewport][x][tileCount - 1].tileY, zoomLevel, true );
					}
				}
				else
				{
					for( var x = 0; x < tileCount; x++ )
					{
						var temp = mapTiles[activeViewport][x][0];
	
						for( var y = 0; y < tileCount - 1; y++ )
							mapTiles[activeViewport][x][y] = mapTiles[activeViewport][x][y + 1];
		
						mapTiles[activeViewport][x][tileCount - 1] = temp;
						mapTiles[activeViewport][x][tileCount - 1].vOffset += tileSize * tileCount;
						mapTiles[activeViewport][x][tileCount - 1].tileY -= tileCount;
						mapTiles[activeViewport][x][tileCount - 1].src = getUrl( mapTiles[activeViewport][x][tileCount - 1].tileX, mapTiles[activeViewport][x][tileCount - 1].tileY, zoomLevel );
					}
				}
			}

			//---------------------------------------------------------------------

			function shuffleUp( )
			{
				if( mapMode == "hyb" )
				{
					for( var x = 0; x < tileCount; x++ )
					{
						var temp = mapTiles[activeViewport][x][tileCount - 1];
						var tempB = mapTiles[activeViewport][x][tileCount - 1].b;
	
						for( var y = tileCount - 1; y > 0; y-- )
						{
							mapTiles[activeViewport][x][y] = mapTiles[activeViewport][x][y - 1];
							mapTiles[activeViewport][x][y].b = mapTiles[activeViewport][x][y - 1].b;
						}
		
						mapTiles[activeViewport][x][0] = temp;
						mapTiles[activeViewport][x][0].b = tempB;

						mapTiles[activeViewport][x][0].b.vOffset = mapTiles[activeViewport][x][0].vOffset -= tileSize * tileCount;
						mapTiles[activeViewport][x][0].b.tileY = mapTiles[activeViewport][x][0].tileY += tileCount;
						
						mapTiles[activeViewport][x][0].src = getUrl( mapTiles[activeViewport][x][0].tileX, mapTiles[activeViewport][x][0].tileY, zoomLevel );
						mapTiles[activeViewport][x][0].b.src = getUrl( mapTiles[activeViewport][x][0].tileX, mapTiles[activeViewport][x][0].tileY, zoomLevel, true );
					}
				}
				else
				{
					for( var x = 0; x < tileCount; x++ )
					{
						var temp = mapTiles[activeViewport][x][tileCount - 1];
	
						for( var y = tileCount - 1; y > 0; y-- )
							mapTiles[activeViewport][x][y] = mapTiles[activeViewport][x][y - 1];
		
						mapTiles[activeViewport][x][0] = temp;
						mapTiles[activeViewport][x][0].vOffset -= tileSize * tileCount;
						mapTiles[activeViewport][x][0].tileY += tileCount;
						mapTiles[activeViewport][x][0].src = getUrl( mapTiles[activeViewport][x][0].tileX, mapTiles[activeViewport][x][0].tileY, zoomLevel );
					}
				}
			}

			//---------------------------------------------------------------------

			function removeSidebarList ( )
			{
				for ( var i = 0; i < sidebarList.length; i++ )
					sidebarList[ i ].removeFromSuperview( );
			
				for ( var i = 0; i <= 1; i++ )
					for ( var n  = 0; n < pinList[ i ].length; n++ )
					{
						pinList[ i ][ n ].pin.removeFromSuperview( );
						pinList[ i ][ n ].pinText.removeFromSuperview( );
					}
			
				sidebarList = new Array ( );
				pinList = new Array ( );
				pinList[0] = new Array ( );
				pinList[1] = new Array ( );
				
				sidebarScrollbar.value = sidebarScrollbar.min;
			}

			//---------------------------------------------------------------------

			function addSidebarItem ( resultNode, oneMatch )
			{
				var c = sidebarList.length;

				sidebarList[ c ] = new Frame ( );
				sidebarList[ c ].textLine = new Array ( );
				sidebarList[ c ].background = new Image ( );
				sidebarList[ c ].pin = new Image ( );
				sidebarList[ c ].pinText = new Text ( );
				sidebarList[ c ].iconCar = new Image ( );
				sidebarList[ c ].iconPrinter = new Image ( );

				sidebarList[ c ].background.src = sidebarList[ c ].originalBackground = ( c % 2 ) ? "Resources/background dark.png" : "Resources/background light.png";

				if ( oneMatch )
					sidebarList[ c ].pin.src = "Resources/pin star.png";
				else
					sidebarList[ c ].pin.src = ( c < 9 ) ? "Resources/pin.png" : "Resources/pin wide.png";
				
				sidebarList[ c ].pin.vOffset = 5;
				sidebarList[ c ].pin.hOffset = ( c < 9 ) ? 18 : 13;
				sidebarList[ c ].pin.tracking = "rectangle";
				sidebarList[ c ].pin.onMouseEnter = "buttonOver = 'sidebarPin" + c + "'";
				sidebarList[ c ].pin.onMouseExit = "buttonOver = null";
				sidebarList[ c ].pin.onMouseUp = pickLocationFromSidebar;
				sidebarList[ c ].pin.index = c;
				sidebarList[ c ].pin.lat = parseFloat( resultNode.evaluate ( "string( Latitude )" ) );
				sidebarList[ c ].pin.lon = parseFloat( resultNode.evaluate ( "string( Longitude )" ) );

				sidebarList[ c ].pinText.font = "Arial Black, Helvetica Black, Helvetica Bold";
				sidebarList[ c ].pinText.color = "#FFFFFF";
				sidebarList[ c ].pinText.shadow = pinTextShadow;
				sidebarList[ c ].pinText.alignment = "center";
				sidebarList[ c ].pinText.size = 14;
				sidebarList[ c ].pinText.hOffset = ( c < 9 ) ? 32 : 29;
				sidebarList[ c ].pinText.vOffset = 20;

				if ( oneMatch )
					sidebarList[ c ].pinText.data = "";
				else
					sidebarList[ c ].pinText.data = c + 1;

				sidebarList[ c ].iconCar.src = "Resources/icon car.png";
				sidebarList[ c ].iconCar.hOffset = 172;
				sidebarList[ c ].iconCar.opacity = 0;
				sidebarList[ c ].iconCar.tracking = "rectangle";
				sidebarList[ c ].iconCar.onMouseEnter = "buttonOver = 'iconCar" + c + "'; sidebarList[ " + c + " ].iconCar.opacity = 200";
				sidebarList[ c ].iconCar.onMouseExit = "buttonOver = null; sidebarList[ " + c + " ].iconCar.opacity = 80";
				sidebarList[ c ].iconCar.onMouseUp = openDrivingDirections;
				sidebarList[ c ].iconCar.tooltip = "Get driving directions";
				sidebarList[ c ].iconCar.index = c;

				sidebarList[ c ].iconPrinter.src = "Resources/icon printer.png";
				sidebarList[ c ].iconPrinter.hOffset = 201;
				sidebarList[ c ].iconPrinter.opacity = 0;
				sidebarList[ c ].iconPrinter.tracking = "rectangle";
				sidebarList[ c ].iconPrinter.onMouseEnter = "buttonOver = 'iconPrinter" + c + "'; sidebarList[ " + c + " ].iconPrinter.opacity = 200";
				sidebarList[ c ].iconPrinter.onMouseExit = "buttonOver = null; sidebarList[ " + c + " ].iconPrinter.opacity = 80";
				sidebarList[ c ].iconPrinter.onMouseUp = openPrintableMap;
				sidebarList[ c ].iconPrinter.tooltip = "Get printable version";
				sidebarList[ c ].iconPrinter.index = c;

				sidebarList[ c ].addSubview( sidebarList[ c ].background );
				sidebarList[ c ].addSubview( sidebarList[ c ].pin );
				sidebarList[ c ].addSubview( sidebarList[ c ].pinText );
				sidebarList[ c ].addSubview( sidebarList[ c ].iconCar );
				sidebarList[ c ].addSubview( sidebarList[ c ].iconPrinter );

				for ( var i = 0; i <= 1; i++ )
				{
					pinList[ i ][ c ] = new Object ( );
					pinList[ i ][ c ].pin = new Image ( );
					pinList[ i ][ c ].pinText = new Text ( );
	
					pinList[ i ][ c ].pin.src = sidebarList[ c ].pin.src;
					pinList[ i ][ c ].pin.hRegistrationPoint = ( c < 9 ) ? 25 : 28;
					pinList[ i ][ c ].pin.vRegistrationPoint = 28;
					pinList[ i ][ c ].pin.hOffset = -100;
					pinList[ i ][ c ].pin.vOffset = -100;
					pinList[ i ][ c ].pin.zOrder = 9000 - ( sidebarList[ c ].pin.lat * 100 );
	
					pinList[ i ][ c ].pinText.font = "Arial Black, Helvetica Black, Helvetica Bold";
					pinList[ i ][ c ].pinText.color = "#FFFFFF";
					pinList[ i ][ c ].pinText.shadow = pinTextShadow;
					pinList[ i ][ c ].pinText.alignment = "center";
					pinList[ i ][ c ].pinText.size = 14;
					pinList[ i ][ c ].pinText.data = sidebarList[ c ].pinText.data;
					pinList[ i ][ c ].pinText.hOffset = -100;
					pinList[ i ][ c ].pinText.vOffset = -100;
					pinList[ i ][ c ].pinText.zOrder = 9000 - ( sidebarList[ c ].pin.lat * 100 - 1 );

					mapViewport[ i ].addSubview( pinList[ i ][ c ].pin );
					mapViewport[ i ].addSubview( pinList[ i ][ c ].pinText );
				}

				var address = resultNode.evaluate ( "string( Address )" );
				
				if ( address != "" )
				{
					sidebarList[ c ].textLine[ 0 ] = new Text ( );
					sidebarList[ c ].textLine[ 0 ].style.fontFamily = "Helvetica, Arial";
					sidebarList[ c ].textLine[ 0 ].style.fontWeight = "Bold";
					sidebarList[ c ].textLine[ 0 ].size = 14;
					sidebarList[ c ].textLine[ 0 ].hOffset = 54;
					sidebarList[ c ].textLine[ 0 ].vOffset = 18;
					sidebarList[ c ].textLine[ 0 ].width = 164;
					sidebarList[ c ].textLine[ 0 ].truncation = "end";
					sidebarList[ c ].textLine[ 0 ].data = normalize ( address );
					
					sidebarList[ c ].addSubview( sidebarList[ c ].textLine[ 0 ] );
				}				

				var city = resultNode.evaluate ( "string( City )" );
				var state = resultNode.evaluate ( "string( State )" );
				var zip = resultNode.evaluate ( "string( Zip )" );
				var country = resultNode.evaluate ( "string( Country )" );

				var address2 = normalize ( city );
				
				if ( address2 != "" && state != "" )
					address2 += " " + state;
				else if ( state != "" ) address2 = ( state.length > 2 ) ? normalize( state ) : state;
				
				if ( address2 != "" && zip != "" )
					address2 += " " + zip;
				else if ( zip != "" ) address2 = zip;
				
				if ( address2 != "" && country != "" )
					address2 += " " + country;
				else if ( country != "" ) address2 = country;
				
				var t = sidebarList[ c ].textLine.length;
				
				if ( address2 != "" )
				{
					sidebarList[ c ].textLine[ t ] = new Text ( );
					sidebarList[ c ].textLine[ t ].style.fontFamily = "Helvetica, Arial";
					sidebarList[ c ].textLine[ t ].style.fontWeight = ( t == 0 ) ? "Bold" : "";
					sidebarList[ c ].textLine[ t ].size = ( t == 0 ) ? 14 : 11;
					sidebarList[ c ].textLine[ t ].hOffset = 54;
					sidebarList[ c ].textLine[ t ].vOffset = ( t == 0 ) ? 18 : 33;
					sidebarList[ c ].textLine[ t ].width = 164;
					sidebarList[ c ].textLine[ t ].truncation = "end";
					sidebarList[ c ].textLine[ t ].data = address2;
					
					sidebarList[ c ].addSubview( sidebarList[ c ].textLine[ t ] );
				}				

				sidebarList[ c ].width = sidebarList[ c ].background.width = 240;
				sidebarList[ c ].height = sidebarList[ c ].background.height = ( sidebarList[ c ].textLine.length == 1 ) ? sidebarList[ c ].height + 3 : sidebarList[ c ].height + 16;

				sidebarList[ c ].vOffset = ( c == 0 ) ? 0 : sidebarList[ c - 1 ].vOffset + sidebarList[ c - 1 ].height;
				
				sidebarList[ c ].iconCar.vOffset = sidebarList[ c ].height - sidebarList[ c ].iconCar.height - 3;
				sidebarList[ c ].iconPrinter.vOffset = sidebarList[ c ].height - sidebarList[ c ].iconPrinter.height - 3;

				sidebarContentMaskFrame.addSubview( sidebarList[ c ] );
			}

			//---------------------------------------------------------------------

			function pickLocationFromSidebar ( )
			{
				if ( buttonOver != "sidebarPin" + this.index )
					return;
				else
				{
					sidebarList[ selectedSidebar ].background.src = sidebarList[ selectedSidebar ].originalBackground;
					sidebarList[ selectedSidebar ].iconCar.opacity = sidebarList[ selectedSidebar ].iconPrinter.opacity = 0;

					sidebarList[ this.index ].background.src = "Resources/background selected.png";
					sidebarList[ this.index ].iconCar.opacity = sidebarList[ this.index ].iconPrinter.opacity = 80;
					selectedSidebar = this.index;

					activeViewport = toggle( activeViewport );

					getMap( this.lat, this.lon, true );
					positionPins ( this.lat, this.lon );
					
					fadeMapFrame( toggle( activeViewport ) );
				}
			}

			//---------------------------------------------------------------------

			function openDrivingDirections ( )
			{
				if ( buttonOver != "iconCar" + this.index )
					return;
				else
				{
					var mapAddress = "http://maps.yahoo.com/dd_result?addr=&csz=&country=&taddr=";
					if( sidebarList[ this.index ].textLine.length > 1 )
						mapAddress += escape ( sidebarList[ this.index ].textLine[ 0 ].data ) + "&tcsz=" + escape ( sidebarList[ this.index ].textLine[ 1 ].data.substring( 0, sidebarList[ this.index ].textLine[ 1 ].data.length - 2 ) );
					else
						mapAddress += "&tcsz=" + escape ( sidebarList[ this.index ].textLine[ 0 ].data.substring( 0, sidebarList[ this.index ].textLine[ 0 ].data.length - 2 ) );

					openURL( mapAddress );
				}
			}

			//---------------------------------------------------------------------

			function openPrintableMap ( )
			{
				if ( buttonOver != "iconPrinter" + this.index )
					return;
				else
				{
					var mapAddress = "http://maps.yahoo.com/maps_result?addr=";
					if( sidebarList[ this.index ].textLine.length > 1 )
						mapAddress += escape ( sidebarList[ this.index ].textLine[ 0 ].data ) + "&csz=" + escape ( sidebarList[ this.index ].textLine[ 1 ].data.substring( 0, sidebarList[ this.index ].textLine[ 1 ].data.length - 2 ) );
					else
						mapAddress += "&csz=" + escape ( sidebarList[ this.index ].textLine[ 0 ].data.substring( 0, sidebarList[ this.index ].textLine[ 0 ].data.length - 2 ) );
					
					mapAddress += "&lat=" + escape ( sidebarList[ this.index ].pin.lat );
					mapAddress += "&lon=" + escape ( sidebarList[ this.index ].pin.lon );
					mapAddress += "&mag=" + escape ( zoomLevel );

					openURL( mapAddress );
				}
			}

			//---------------------------------------------------------------------

			function positionPins ( lat, lon )
			{
				var pj = new MercatorProjection( zoomLevel, tileSize, tileSize );
				var centerView = Math.floor( mapViewport[ activeViewport ].width / 2 );
				var px = pj.ll_to_pxy( lat, lon );

				var tilesX = Math.floor( px.m_x / tileSize );
				var tilesY = Math.floor( px.m_y / tileSize );

				var offsetX = px.m_x - ( tilesX * tileSize );
				var offsetY = tileSize - ( px.m_y - ( tilesY * tileSize ) );

				offsetX = centerView - offsetX;
				offsetY = centerView - offsetY;

				for ( var i = 0; i < pinList[ activeViewport ].length; i++ )
				{
					var pxPin = pj.ll_to_pxy( sidebarList[ i ].pin.lat, sidebarList[ i ].pin.lon );

					pinList[ activeViewport ][ i ].pin.hOffset = pxPin.m_x - ( tilesX * tileSize ) + offsetX;
					pinList[ activeViewport ][ i ].pin.vOffset = tileSize - ( pxPin.m_y - ( tilesY * tileSize ) ) + offsetY;

					pinList[ activeViewport ][ i ].pinText.hOffset = pinList[ activeViewport ][ i ].pin.hOffset - 11;
					pinList[ activeViewport ][ i ].pinText.vOffset = pinList[ activeViewport ][ i ].pin.vOffset - 13;
				}
			}

			//---------------------------------------------------------------------

			function handleScrollDisclosure( triggerWhenDone )
			{
			
				if ( system.platform == "windows" )
					theHeight = screen.availHeight + screen.availTop;
				else
					theHeight = screen.height;

				movingWindow = false;

				var duration = 300;

				if ( scrollIsClosed )
				{
					if ( cScroll != null )
					{
						cScroll.kill( );
						cScroll = null;
					}
				
					scrollIsClosed = false;
					
					oScroll = new CustomAnimation( 1, openScroll );
					oScroll.duration = duration;
					oScroll.startPosition = footer.vOffset;
					oScroll.triggerWhenDone = triggerWhenDone;
					
					animator.start( oScroll );

					zoomControlOut.onMouseUp = zoomControlOut.storedOnMouseUp;
					zoomControlIn.onMouseUp = zoomControlIn.storedOnMouseUp;
					zoomControlThumb.onMouseDrag = zoomControlThumb.storedOnMouseDrag;
					zoomControlThumb.onMouseDown = zoomControlThumb.storedOnMouseDown;
					zoomControlThumb.onMouseUp = zoomControlThumb.storedOnMouseUp;
				}
				else
				{
					if ( !sidebarIsClosed )
						handleSidebarDisclosure( true );
					else
						{
						if( oScroll != null )
						{
							oScroll.kill( );
							oScroll = null;
						}
						scrollIsClosed = true;
	
						zoomControlOut.storedOnMouseUp = zoomControlOut.onMouseUp;
						zoomControlIn.storedOnMouseUp = zoomControlIn.onMouseUp;
						zoomControlThumb.storedOnMouseDrag = zoomControlThumb.onMouseDrag;
						zoomControlThumb.storedOnMouseDown = zoomControlThumb.onMouseDown;
						zoomControlThumb.storedOnMouseUp = zoomControlThumb.onMouseUp;
						
						zoomControlOut.onMouseUp =
						zoomControlIn.onMouseUp =
						zoomControlThumb.onMouseDrag =
						zoomControlThumb.onMouseDown =
						zoomControlThumb.onMouseUp = "";
	
						if ( mainWindow.hOffsetFinal != mainWindow.hOffset || mainWindow.vOffsetFinal != mainWindow.vOffset ) mainWindow.hasMoved = false;
	
						cScroll = new CustomAnimation( 1, closeScroll );
						cScroll.duration = duration;
						cScroll.startPosition = footer.vOffset;
	
						animator.start( cScroll );
					}
				}
			}

			//---------------------------------------------------------------------

			function handleSidebarDisclosure( triggerWhenDone )
			{
				var duration = 250;

				if ( sidebarIsClosed )
				{
					if ( cSidebar != null )
					{
						cSidebar.kill( );
						cSidebar = null;
					}
					sidebarIsClosed = false;
					sidebarFrame.visible = true

					oSidebar = new CustomAnimation( 1, openSidebar );
					oSidebar.duration = duration;
					oSidebar.startPosition = sidebarFrame.hOffset;
					
					animator.start( oSidebar );
				}
				else
				{
					if ( oSidebar != null )
					{
						oSidebar.kill( );
						oSidebar = null;
					}
					sidebarIsClosed = true;

					cSidebar = new CustomAnimation( 1, closeSidebar, setSidebarInvisible );
					cSidebar.duration = duration;
					cSidebar.startPosition = sidebarFrame.hOffset;
					cSidebar.triggerWhenDone = triggerWhenDone;
					
					animator.start( cSidebar );
				}
			}

			//---------------------------------------------------------------------

			function closeScroll( )
			{
				var percent = ( animator.milliseconds - this.startTime ) / this.duration;
				var ease = animator.ease( this.startPosition, 0, percent, animator.kEaseOut );
				
				scrollFrame.height = 36 + ease;
				disclosureButtonArrow.rotation = ease * 0.52786;

				footer.vOffset = ease;

		 		if ( mainWindow.hasMoved )
		 		{
		 			mainWindow.vOffset = mainWindow.vOffsetBump - ease;
		 			if ( mainWindow.vOffset >= mainWindow.vOffsetOriginal )
		 			{
		 				mainWindow.vOffset = mainWindow.vOffsetOriginal;
		 				mainWindow.hasMoved = false;
		 			}
		 		}

				if ( animator.milliseconds >= ( this.startTime + this.duration ) )
				{
					scrollFrame.height = 36;
					disclosureButtonArrow.rotation = 0;
					footer.vOffset = 0;
					mainWindow.hasMoved = false;
					return false;
				}
				return true;
			}

			//---------------------------------------------------------------------

			function openScroll( )
			{
				var percent = ( animator.milliseconds - this.startTime ) / this.duration;
				var ease = animator.ease( this.startPosition, 341, percent, animator.kEaseOut );

				scrollFrame.height = 36 + ease;
				disclosureButtonArrow.rotation = ease * 0.52786;

				footer.vOffset = ease;

				if ( !movingWindow )
				{
					if ( mainWindow.vOffset + footer.vOffset + footer.height > theHeight )
					{
						movingWindow = true;
						mainWindow.hasMoved = true;
						mainWindow.vOffsetOriginal = mainWindow.vOffset;
						mainWindow.vOffsetBump = theHeight - footer.vOffset - footer.height + ease;
					}
				}
				
				if ( movingWindow ) mainWindow.vOffset = mainWindow.vOffsetBump - ease;

				if ( animator.milliseconds >= ( this.startTime + this.duration ) )
				{
					scrollFrame.height = 377;
					disclosureButtonArrow.rotation = 180;
					footer.vOffset = 341;
					if ( movingWindow ) mainWindow.vOffset = theHeight - 389;
					mainWindow.hOffsetFinal = mainWindow.hOffset;
					mainWindow.vOffsetFinal = mainWindow.vOffset;
					if ( this.triggerWhenDone ) handleSidebarDisclosure( );
					return false;
				}
				return true;
			}

			//---------------------------------------------------------------------

			function closeSidebar( )
			{
				var percent = ( animator.milliseconds - this.startTime ) / this.duration;
				var ease = animator.ease( this.startPosition, 86, percent, animator.kEaseOut );
				
				sidebarFrame.hOffset = ease;
				sidebarDisclosureButton.rotation = ( ease - 86 ) * 0.737704918033;

				if ( animator.milliseconds >= ( this.startTime + this.duration ) )
				{
					sidebarFrame.hOffset = 86;
					sidebarDisclosureButton.rotation = 0;
					if ( this.triggerWhenDone ) handleScrollDisclosure( );
					return false;
				}
				return true;
			}

			//---------------------------------------------------------------------

			function openSidebar( )
			{
				var percent = ( animator.milliseconds - this.startTime ) / this.duration;
				var ease = animator.ease( this.startPosition, 330, percent, animator.kEaseOut );
				
				sidebarFrame.hOffset = ease;
				sidebarDisclosureButton.rotation = ( ease - 86 ) * 0.737704918033;

				if ( animator.milliseconds >= ( this.startTime + this.duration ) )
				{
					sidebarFrame.hOffset = 330;
					sidebarDisclosureButton.rotation = 180;
					return false;
				}
				return true;
			}

			//---------------------------------------------------------------------

			function setSidebarInvisible(  )
			{
				sidebarFrame.visible = false;
			}

			//---------------------------------------------------------------------

			function fadeMapFrame( whichMap )
			{
				mapViewport[toggle( whichMap )].opacity = 255;
			
				var fader = new FadeAnimation( mapViewport[whichMap], 0, 1000, animator.kEaseNone, fadeMapFrameDone );
				animator.start( fader );
			}

			//---------------------------------------------------------------------

			function fadePins( finalOpacity )
			{
				var fader1 = new FadeAnimation( pin[0], finalOpacity, 250, animator.kEaseNone );
				var fader2 = new FadeAnimation( pin[0], finalOpacity, 250, animator.kEaseNone );
				animator.start( Array( fader1, fader2 ) );
			}

			//---------------------------------------------------------------------

			function fadeMapFrameDone( )
			{
				mapViewport[activeViewport].zOrder = 11;
				mapViewport[toggle( activeViewport )].zOrder = 10;

//				mapViewport[activeViewport].opacity = 255;
//				mapViewport[toggle( activeViewport )].opacity = 255;

				mapViewport[activeViewport].opacity = 255;
				mapViewport[toggle( activeViewport )].opacity = 0;
			}

			//---------------------------------------------------------------------

			function handleKeyPress( )
			{
				if ( system.event.keyString == "Tab" )
					searchField.rejectKeyPress( );
				else if ( system.event.keyString == "Return" || system.event.keyString == "Enter" )
				{
					searchField.rejectKeyPress( );

					if( searchField.data.replace( /[^\w]/g, "" ) != "" )
					doSearch( );
					else
						searchField.data = "";

					searchField.loseFocus( );
				}
			}

			//---------------------------------------------------------------------

			function handleSearchFieldGainFocus( )
			{
				if( searchField.data == "Search" )
				{
					searchField.data = "";
					searchField.color = "#000000";
				}
				searchFieldFocusRing.opacity = 255;
			}

			//---------------------------------------------------------------------

			function handleSearchFieldLoseFocus( )
			{
				if( searchField.data == "" )
				{
					searchField.data = "Search";
					searchField.color = "#bababa";
				}
				searchFieldFocusRing.opacity = 0;
			}

			//---------------------------------------------------------------------

			function handleRecentSearchMenu( )
			{
				if ( preferences.lastSearchItems.value != "" )
				{
					var items = new Array( );
					var mySearch = 0;
					myItems = preferences.lastSearchItems.value.split( "*a*" );
					
					items[ mySearch ] = new MenuItem();
					items[ mySearch ].title = "Recent Searches";
					items[ mySearch ].enabled = false;
					mySearch++;
	
					for ( item in myItems )
					{	
						if ( myItems[ item ] != "" )
						{
							items[ mySearch]  = new MenuItem();
							items[ mySearch ].title = myItems[item];
							items[ mySearch ].onSelect = "searchField.data = '" + myItems[ item ].replace( /'/, "\\'") + "'; searchField.color = '#000000' ; searchField.focus( )";
							mySearch++;
						}
					}
	
					items[ mySearch ] = new MenuItem( );
					items[ mySearch ].title = "-";
					items[ mySearch ].enabled = false;
					mySearch++;
					items[ mySearch ] = new MenuItem();
					items[ mySearch ].title = "Clear Recent Searches";
					items[ mySearch ].onSelect = "preferences.lastSearchItems.value = ''";
				}
				else
				{
					var items = new Array( );
					
					items[ 0 ] = new MenuItem( );
					items[ 0 ].title = "No Recent Searches";
					items[ 0 ].enabled = 0;
				}
				
				popupMenu( items, searchIcon.hOffset + 1, searchIcon.vOffset + 17 );
			}

			//---------------------------------------------------------------------

			function zoomIn( )
			{
				if ( buttonOver == "zoomControlIn" )
				{
					var center = findCenterLatLon( );
	
					zoomLevel--;
	
					if ( zoomLevel == maxZoomLevel )
						zoomControlIn.onMouseUp = "";
									
					if ( zoomLevel == minZoomLevel - 1 ) 
						zoomControlOut.onMouseUp = "zoomOut( )";
					
					zoomControlThumb.hOffset = 91 - zoomThumbStep * ( zoomLevel - 1 );
					
					if ( haveRenderedMap )
					{
						activeViewport = toggle( activeViewport );
		
						getMap( center.m_lat, center.m_lon );
						positionPins( center.m_lat, center.m_lon );
	
						fadeMapFrame( toggle( activeViewport ) );
					}
				}
			}

			//---------------------------------------------------------------------

			function zoomOut( )
			{
				if ( buttonOver == "zoomControlOut" )
				{
					var center = findCenterLatLon( );
	
					zoomLevel++;
	
					if ( zoomLevel == minZoomLevel )
						zoomControlOut.onMouseUp = "";
	
					if ( zoomLevel == maxZoomLevel + 1 ) 
						zoomControlIn.onMouseUp = "zoomIn( )";
	
					zoomControlThumb.hOffset = 91 - zoomThumbStep * ( zoomLevel - 1 );
	
					if ( haveRenderedMap )
					{
						activeViewport = toggle( activeViewport );
		
						getMap( center.m_lat, center.m_lon );
						positionPins( center.m_lat, center.m_lon );
	
						fadeMapFrame( toggle( activeViewport ) );
					}
				}
			}


			//---------------------------------------------------------------------

			function zoomTo( newZoomLevel, suppressNewMap )
			{
				if ( !newZoomLevel ) var newZoomLevel = Math.abs ( Math.round ( ( zoomControlThumb.hOffset - 32 ) / zoomThumbStep ) - minZoomLevel );
			
				if ( zoomLevel == newZoomLevel )
					return;
				else
				{
					zoomControlThumb.hOffset = Math.round (32 + ( minZoomLevel - newZoomLevel ) * zoomThumbStep );
				
					var center = findCenterLatLon( );

					zoomLevel = newZoomLevel;

					if ( zoomLevel == minZoomLevel )
					{
						zoomControlOut.onMouseUp = "";
						zoomControlIn.onMouseUp = "zoomIn( )";
					}
					else if ( zoomLevel == maxZoomLevel )
					{
						zoomControlIn.onMouseUp = "";
						zoomControlOut.onMouseUp = "zoomOut( )";
					}
					else
					{
						zoomControlIn.onMouseUp = "zoomIn( )";
						zoomControlOut.onMouseUp = "zoomOut( )";
					}
					
					if ( !suppressNewMap && haveRenderedMap )
					{
						activeViewport = toggle( activeViewport );

						getMap( center.m_lat, center.m_lon );
						positionPins( center.m_lat, center.m_lon );
	
						fadeMapFrame( toggle( activeViewport ) );
					}
				}
			}



			//---------------------------------------------------------------------

			function getMap( lat, lon, resetMaster )
			{
				if ( resetMaster )
				{
					masterLat = lat;
					masterLon = lon;
				}
			
				var centerTile = Math.floor( tileCount / 2 );
				var centerView = Math.floor( mapViewport[activeViewport].width / 2 );

				var pj = new MercatorProjection( zoomLevel, tileSize, tileSize );
				var xy = pj.ll_to_xy( lat, lon );

				var px = pj.ll_to_pxy( lat, lon );

				var tilesX = Math.floor( px.m_x / tileSize );
				var tilesY = Math.floor( px.m_y / tileSize );

				var offsetX = px.m_x - ( tilesX * tileSize );
				var offsetY = tileSize - ( px.m_y - ( tilesY * tileSize ) );

				offsetX = centerView - offsetX;
				offsetY = centerView - offsetY;
		
				var oMidbyTile =
				{
					row: Math.floor( ( tileCount ) / 2 ), 
					col: Math.floor( ( tileCount ) / 2 )
				};
			
				var iTileRow = xy.m_row - oMidbyTile.row;
				var iTileCol = xy.m_col - oMidbyTile.col;

				generateTile( centerTile, centerTile, tilesX, tilesY, offsetX, offsetY );

				generateTile( centerTile - 1, centerTile , tilesX - 1, tilesY, offsetX - tileSize, offsetY ); // L
				generateTile( centerTile, centerTile - 1, tilesX, tilesY + 1, offsetX, offsetY - tileSize ); // T
				generateTile( centerTile + 1, centerTile , tilesX + 1, tilesY, offsetX + tileSize, offsetY ); // R
				generateTile( centerTile, centerTile + 1, tilesX, tilesY - 1, offsetX, offsetY + tileSize ); // B

				generateTile( centerTile - 1, centerTile - 1, tilesX - 1, tilesY + 1, offsetX - tileSize, offsetY - tileSize ); // UL
				generateTile( centerTile + 1, centerTile - 1, tilesX + 1, tilesY + 1, offsetX + tileSize, offsetY - tileSize); // UR
				generateTile( centerTile - 1, centerTile + 1, tilesX - 1, tilesY - 1, offsetX - tileSize, offsetY + tileSize ); // LL
				generateTile( centerTile + 1, centerTile + 1, tilesX + 1, tilesY - 1, offsetX + tileSize, offsetY + tileSize); // LR
				
				if( centerTile > 1 )
				{
					for ( var n = 2; n <= centerTile; n++ )
					{
						var tileSize_n = tileSize * n;
						
						generateTile( centerTile - n, centerTile, tilesX - n, tilesY, offsetX - tileSize_n, offsetY ); // L
						generateTile( centerTile, centerTile - n, tilesX, tilesY + n, offsetX, offsetY - tileSize_n ); // T
						generateTile( centerTile + n, centerTile, tilesX + n, tilesY, offsetX + tileSize_n, offsetY ); // R
						generateTile( centerTile, centerTile + n, tilesX, tilesY - n, offsetX, offsetY + tileSize_n ); // B
						
						for ( var i = 1; i < centerTile; i++ )
						{
							var tileSize_i = tileSize * i;

							generateTile( centerTile - i, centerTile - n, tilesX - i, tilesY + n, offsetX - tileSize_i, offsetY - tileSize_n ); // T
							generateTile( centerTile + i, centerTile - n, tilesX + i, tilesY + n, offsetX + tileSize_i, offsetY - tileSize_n ); // T

							generateTile( centerTile - i, centerTile + n, tilesX - i, tilesY - n, offsetX - tileSize_i, offsetY + tileSize_n ); // B
							generateTile( centerTile + i, centerTile + n, tilesX + i, tilesY - n, offsetX + tileSize_i, offsetY + tileSize_n ); // B

							generateTile( centerTile - n, centerTile - i, tilesX - n, tilesY + i, offsetX - tileSize_n, offsetY - tileSize_i ); // L
							generateTile( centerTile - n, centerTile + i, tilesX - n, tilesY - i, offsetX - tileSize_n, offsetY + tileSize_i ); // L

							generateTile( centerTile + n, centerTile - i, tilesX + n, tilesY + i, offsetX + tileSize_n, offsetY - tileSize_i ); // R
							generateTile( centerTile + n, centerTile + i, tilesX + n, tilesY - i, offsetX + tileSize_n, offsetY + tileSize_i ); // R
						}
						generateTile( centerTile - n, centerTile - n, tilesX - n, tilesY + n, offsetX - tileSize_n, offsetY - tileSize_n ); // UL
						generateTile( centerTile + n, centerTile - n, tilesX + n, tilesY + n, offsetX + tileSize_n, offsetY - tileSize_n); // UR
						generateTile( centerTile - n, centerTile + n, tilesX - n, tilesY - n, offsetX - tileSize_n, offsetY + tileSize_n ); // LL
						generateTile( centerTile + n, centerTile + n, tilesX + n, tilesY - n, offsetX + tileSize_n, offsetY + tileSize_n); // LR
					}
				}
			}

			//---------------------------------------------------------------------

			function doSearch ( )
			{
				var reusedTerm = false;
				var mySearchList = preferences.lastSearchItems.value.split("*a*");
		
				for (item in mySearchList)
				{
					if ( mySearchList[ item ] == searchField.data )
						var reusedTerm = true;
				}
				
				if ( !reusedTerm )
				{			
					if ( mySearchList.length == storedSearchCount )
					{
						mySearchList.splice( 0, 1 );
					}
					
					preferences.lastSearchItems.value = mySearchList.join( "*a*" ) + "*a*" + searchField.data;
				}
				else
					preferences.lastSearchItems.value = mySearchList.join( "*a*" );

				var url = new URL( );
				url.location = "http://api.local.yahoo.com/MapsService/V1/geocode?appid=Konfabulator&location=" + escape( searchField.data );
				url.fetch( );
				
				returnedData = url.responseData;

				var dom = XMLDOM.parse ( returnedData );

				if ( dom.evaluate( "/Error" ).length > 0 )
				{
					if ( dom.evaluate( "string( /Error/Message[ 1 ] )" ) == "unable to parse location" )
						alert( 'Could not find the location "' + searchField.data + '" on the Map. Please try a different spelling or use additional terms such as state or zip code.' );
					else
						alert( "Maps: " + dom.evaluate( "string( /Error/Message[ 1 ] )" ) )
				}
				else
				{
					masterLat = parseFloat( dom.evaluate ( "string( /ResultSet/Result/Latitude[ 1 ] )" ) );
					masterLon = parseFloat( dom.evaluate ( "string( /ResultSet/Result/Longitude[ 1 ] )" ) );

					var precision = dom.evaluate ( "string( /ResultSet/Result/@precision )" );
					var newZoom = 8;

					if ( precision == "address" || precision == "street" || precision == "zip+4" || precision == "zip+2" )
						newZoom = 3;
					else if ( precision == "zip" )
						newZoom = 5;
					else if ( precision == "city" )
						newZoom = 6;
					else if ( precision == "state" )
						newZoom = 12;
					else if ( precision == "country" )
						newZoom = 15;
						
					zoomTo ( newZoom, true );

					resultList = dom.evaluate ( "//ResultSet/Result" );

					if ( sidebarList ) removeSidebarList ( );

					for ( var i = 0; i < resultList.length; i++ )
						addSidebarItem ( resultList.item( i ), ( resultList.length == 1 ) );

					selectedSidebar = 0;

					sidebarList[ selectedSidebar ].background.src = "Resources/background selected.png";
					sidebarList[ selectedSidebar ].iconCar.opacity = sidebarList[ selectedSidebar ].iconPrinter.opacity = 80;

					getMap ( masterLat, masterLon );
					positionPins( masterLat, masterLon );

					haveRenderedMap = true;

					if ( scrollIsClosed ) handleScrollDisclosure ( ( sidebarIsClosed && resultList.length > 1 ) );
					
//					if ( sidebarIsClosed && resultList.length > 1 ) handleSidebarDisclosure ( );
				}
			}

			//---------------------------------------------------------------------

			function findCenterLatLon( )
			{
				var pj = new MercatorProjection( zoomLevel, tileSize, tileSize );

				var viewportCenterH = mapViewport[activeViewport].width / 2;
				var viewportCenterV = mapViewport[activeViewport].height / 2;

				var tileX = mapTiles[activeViewport][0][0].tileX;
				var tileY = mapTiles[activeViewport][0][0].tileY;
				var offsetH = ( viewportCenterH - mapTiles[activeViewport][0][0].hOffset );
				var offsetV = ( viewportCenterV - mapTiles[activeViewport][0][0].vOffset );

				var pixelX = ( tileX * tileSize ) + offsetH;
				var pixelY = ( tileY * tileSize ) - offsetV + tileSize;

				var centerTile = pj.pxy_to_ll( pixelX, pixelY );

				return centerTile;
			}

			//---------------------------------------------------------------------
			// Converted YMap API functions follow
			//---------------------------------------------------------------------

			function TileXY( p_col, p_row, p_x, p_y )
			{
				this.m_col = p_col;
				this.m_row = p_row;
				this.m_x = p_x;
				this.m_y = p_y;
			}
			
			function TileXY( )
			{
				this.m_col = 0;
				this.m_row = 0;
				this.m_x = 0;
				this.m_y = 0;
			}
			
			function PixelXY( )
			{
				this.m_x = 0;
				this.m_y = 0;
			}
			
			function LatLon( )
			{
				this.m_lat = 0;
				this.m_lon = 0;
			}
			
			function LatLon( p_lat, p_lon )
			{
				this.m_lat = p_lat;
				this.m_lon = p_lon;
			}
			
			var PI = 3.1415926;
			var M_PER_DEGREE = 111111;
			var EARTH_CIRCUM_M = M_PER_DEGREE * 360;
			var RAD_PER_DEG = PI / 180.0;
			var MAXLEVEL = 18;

			function Projection( p_level, clat, tilew, tileh )
			{
				this.init( p_level, clat, tilew, tileh );
			}
			
			Projection.prototype.init = function ( p_level, clat, tilew, tileh )
			{
				if( p_level < 1 ) this.level_ = 1;
				else if( p_level > MAXLEVEL ) this.level_ = MAXLEVEL;
				else this.level_ = p_level;
		
				this.tile_w_ = tilew;
				this.tile_h_ = tileh;
		
				this.status_ = 1;
				this.isok = isok;
			
				this.tile_width = tile_width;
				this.pixel_width = pixel_width;
				this.tile_height = tile_height;
				this.pixel_height = pixel_height;
				this.mpp = mpp;
				this.level = level;
				this.tile_size = tile_size;
			
				this.scaleKm = scaleKm;
				this.scaleMiles = scaleMiles;
				this.scaleFeet = scaleFeet;
				this.pix_to_tile = pix_to_tile;
			}

			function pix_to_tile( xp, yp )
			{
				v_xy = new TileXY( );
			
				ypos = Math.abs( yp );
		
				v_xy.m_col = Math.floor( xp / this.tile_w_ );
				v_xy.m_x = xp % this.tile_w_;
				v_xy.m_row = Math.floor( ypos / this.tile_h_ );
				v_xy.m_y = ypos % this.tile_h_;
				
				if( yp < 0 )
				{
					v_xy.m_row = -v_xy.m_row;
					if( y > 0 )
					{
						v_xy.m_row--;
						v_xy.m_y = this.tile_h_ - v_xy.m_y;
					}
				}
				return v_xy;
			}

			function tile_width( ) { return this.ntiles_w_; }
			function pixel_width( ) { return this.ntiles_w_ * this.tile_w_; }
			function tile_height( ) { return this.ntiles_h_; }
			function pixel_height( ) { return this.ntiles_h_ * this.tile_h_; }
			function mpp( ) { return this.meters_per_pixel_; }
			function level( ) { return this.level_; }
			function tile_size( ) { return this.tile_w_; }
			function isok( ) { return this.status_ == 1; }

			function scaleKm( km, clat )
			{
				 return( this.scaleMeters(km * 1000.0, clat ) );
			}
			
			function scaleMiles( miles, clat )
			{
				 return( this.scaleMeters(miles * 1609.344, clat ) );
			}
			
			function scaleFeet( feet, clat )
			{
				 return( this.scaleMeters( feet / 3.282, clat ) );
			}

			function scaleMeters( meters, clat )
			{
				 return( parseInt( meters / this.mpp( ) + 0.5 ) );
			}

			function sinh( x )
			{
				ret = Math.exp( x );
				ret = ( ret - 1 / ret ) / 2;
				return ret;
			}

			function type( )
			{
				return 'M';
			}

			function mpp_m( clat )
			{
				return( this.meters_per_pixel_ * Math.cos( clat * RAD_PER_DEG ) );
			}

			function MercatorProjection( p_level, tilew, tileh )
			{
				this.init( p_level, 0.0, tilew, tileh );
				circum_px = 1 << ( 26 - this.level_ );
		
				this.ntiles_w_ = circum_px / this.tile_w_;
				this.ntiles_h_ = circum_px / this.tile_h_;
				this.meters_per_pixel_ = EARTH_CIRCUM_M / circum_px;
				this.x_per_lon_ = circum_px / 360.0;
		
				this.ll_to_xy = ll_to_xy;
				this.xy_to_ll = xy_to_ll;
				this.type = type;
				this.mpp_m = mpp_m;
				this.scaleMeters = scaleMeters;
				this.ll_to_pxy = ll_to_pxy;
				this.pxy_to_ll = pxy_to_ll;
			}
			
			MercatorProjection.prototype = new Projection();
			MercatorProjection.prototype.constructor = MercatorProjection;
			MercatorProjection.superclass = Projection.prototype;

			function ll_to_pxy( lat, lon )
			{
				 alat = Math.abs( lat );
				 alon = lon + 180.0;
			
				 v_pxy = new PixelXY( );
			
				 if( alat >= 90.0 || alon > 360.0 || alon < 0.0 ) return v_pxy;
			
				 alat *= RAD_PER_DEG;
			
				 v_pxy.m_x = parseInt( alon * this.x_per_lon_ );
				 ytemp = Math.log( Math.tan( alat ) + 1.0 / Math.cos( alat ) ) / PI;
				 v_pxy.m_y = parseInt( ytemp * this.pixel_height( ) ) / 2;
			
				 if( lat < 0 ) v_pxy.m_y = -v_pxy.m_y;
			
				 this.status_ = 1;
				 return v_pxy;
			}
			
			function ll_to_xy( lat, lon )
			{
				 v_xy = new TileXY( );
			
				 v_pxy = this.ll_to_pxy( lat, lon );
				 if ( this.isok( ) ) v_xy = this.pix_to_tile( v_pxy.m_x, v_pxy.m_y );
			
				 return v_xy;
			}
			
			function pxy_to_ll( x_pixel, y_pixel )
			{
				this.status_ = 0;
				v_ll = new LatLon( );
		
				alon = x_pixel / this.x_per_lon_;
				alat = ( y_pixel / ( this.pixel_height( ) / 2.0 ) ) * PI;
		
				alat = Math.atan( sinh( alat ) ) / RAD_PER_DEG;
		
				if( alon < 0 || alon > 360.0 ) return v_ll;
				v_ll.m_lon = alon - 180.0;
				if( alat <= -90.0 || alat >= 90.0 ) return v_ll;
				v_ll.m_lat = alat;
		
				this.status_ = 1;
		
				return v_ll;
			}
			
			function xy_to_ll( col, row, x, y )
			{
				x_pixel = col * this.tile_w_ + x;
				y_pixel = row * this.tile_h_ + y;
				
				return( this.pxy_to_ll( x_pixel, y_pixel ) );       
			}

		]]>
	</action>

	<preference name="lastSearchItems">
		<hidden>true</hidden>
		<type>text</type>
		<defaultValue></defaultValue>
	</preference>

	<about-box>
		<image>Resources/About.png</image>
		<about-version>
			<font>Arial</font>
			<size>10</size>
			<hOffset>112</hOffset>
			<vOffset>141</vOffset>
			<color>#ffffff</color>
			<shadow>
				<color>#000000</color>
				<hOffset>0</hOffset>
				<vOffset>1</vOffset>
			</shadow>
		</about-version>

		<about-text>
			<data>Yahoo! Maps Terms Of Use</data>
			<url>http://help.yahoo.com/help/us/maps/maps-24.html</url>
			<font>Arial</font>
			<size>10</size>
			<hOffset>112</hOffset>
			<vOffset>177</vOffset>
			<color>#ffffff</color>
			<shadow>
				<color>#000000</color>
				<hOffset>0</hOffset>
				<vOffset>1</vOffset>
			</shadow>
		</about-text>

		<about-text>
			<data>Copyright Policy</data>
			<url>http://docs.yahoo.com/info/copyright/copyright.html</url>
			<font>Arial</font>
			<size>10</size>
			<hOffset>112</hOffset>
			<vOffset>191</vOffset>
			<color>#ffffff</color>
			<shadow>
				<color>#000000</color>
				<hOffset>0</hOffset>
				<vOffset>1</vOffset>
			</shadow>
		</about-text>

		<about-text>
			<data>Terms Of Service</data>
			<url>http://docs.yahoo.com/info/terms/</url>
			<font>Arial</font>
			<size>10</size>
			<hOffset>202</hOffset>
			<vOffset>191</vOffset>
			<color>#ffffff</color>
			<shadow>
				<color>#000000</color>
				<hOffset>0</hOffset>
				<vOffset>1</vOffset>
			</shadow>
		</about-text>

		<about-text>
			<data>Privacy Policy</data>
			<url>http://privacy.yahoo.com/privacy/us/maps/</url>
			<font>Arial</font>
			<size>10</size>
			<hOffset>299</hOffset>
			<vOffset>191</vOffset>
			<color>#ffffff</color>
			<shadow>
				<color>#000000</color>
				<hOffset>0</hOffset>
				<vOffset>1</vOffset>
			</shadow>
		</about-text>
		
	</about-box>

</widget>
